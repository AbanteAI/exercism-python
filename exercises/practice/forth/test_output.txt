============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-7.4.0, pluggy-1.3.0
rootdir: /home/jake/Development/mentat/tests/benchmarks/repos/exercism-python
configfile: pytest.ini
plugins: mock-3.11.1, reportlog-0.4.0, asyncio-0.21.1, xdist-3.3.1
asyncio: mode=strict
collected 48 items

exercises/practice/forth/forth_test.py ...F....F.....................F.. [ 68%]
.....FFFFFF...F                                                          [100%]

=================================== FAILURES ===================================
______ ForthTest.test_case_insensitivity_definitions_are_case_insensitive ______

self = <forth_test.ForthTest testMethod=test_case_insensitivity_definitions_are_case_insensitive>

    def test_case_insensitivity_definitions_are_case_insensitive(self):
>       self.assertEqual(evaluate([": SWAP DUP Dup dup ;", "1 swap"]), [1, 1, 1, 1])

exercises/practice/forth/forth_test.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': SWAP DUP Dup dup ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
__ ForthTest.test_case_insensitivity_user_defined_words_are_case_insensitive ___

self = <forth_test.ForthTest testMethod=test_case_insensitivity_user_defined_words_are_case_insensitive>

    def test_case_insensitivity_user_defined_words_are_case_insensitive(self):
>       self.assertEqual(evaluate([": foo dup ;", "1 FOO Foo foo"]), [1, 1, 1, 1])

exercises/practice/forth/forth_test.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': foo dup ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
__ ForthTest.test_parsing_and_numbers_pushes_negative_numbers_onto_the_stack ___

self = <forth_test.ForthTest testMethod=test_parsing_and_numbers_pushes_negative_numbers_onto_the_stack>

    def test_parsing_and_numbers_pushes_negative_numbers_onto_the_stack(self):
>       self.assertEqual(evaluate(["-1 -2 -3 -4 -5"]), [-1, -2, -3, -4, -5])

exercises/practice/forth/forth_test.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = '-1 -2 -3 -4 -5'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
                    raise ValueError("illegal operation")
                definition = []
                while tokens and tokens[0] != ';':
                    definition.append(tokens.pop(0))
                if not tokens or tokens[0] != ';':
                    raise ValueError("incomplete definition")
                tokens.pop(0)  # Remove the closing ';'
                define_word(name, ' '.join(definition))
            else:
>               raise ValueError("undefined operation")
E               ValueError: undefined operation

exercises/practice/forth/forth.py:73: ValueError
_______ ForthTest.test_user_defined_words_can_consist_of_built_in_words ________

self = <forth_test.ForthTest testMethod=test_user_defined_words_can_consist_of_built_in_words>

    def test_user_defined_words_can_consist_of_built_in_words(self):
>       self.assertEqual(evaluate([": dup-twice dup dup ;", "1 dup-twice"]), [1, 1, 1])

exercises/practice/forth/forth_test.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': dup-twice dup dup ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
_ ForthTest.test_user_defined_words_can_define_word_that_uses_word_with_the_same_name _

self = <forth_test.ForthTest testMethod=test_user_defined_words_can_define_word_that_uses_word_with_the_same_name>

    def test_user_defined_words_can_define_word_that_uses_word_with_the_same_name(self):
>       self.assertEqual(evaluate([": foo 10 ;", ": foo foo 1 + ;", "foo"]), [11])

exercises/practice/forth/forth_test.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': foo 10 ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
______ ForthTest.test_user_defined_words_can_override_built_in_operators _______

self = <forth_test.ForthTest testMethod=test_user_defined_words_can_override_built_in_operators>

    def test_user_defined_words_can_override_built_in_operators(self):
>       self.assertEqual(evaluate([": + * ;", "3 4 +"]), [12])

exercises/practice/forth/forth_test.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': + * ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
________ ForthTest.test_user_defined_words_can_override_built_in_words _________

self = <forth_test.ForthTest testMethod=test_user_defined_words_can_override_built_in_words>

    def test_user_defined_words_can_override_built_in_words(self):
>       self.assertEqual(evaluate([": swap dup ;", "1 swap"]), [1, 1])

exercises/practice/forth/forth_test.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': swap dup ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
___ ForthTest.test_user_defined_words_can_override_other_user_defined_words ____

self = <forth_test.ForthTest testMethod=test_user_defined_words_can_override_other_user_defined_words>

    def test_user_defined_words_can_override_other_user_defined_words(self):
        self.assertEqual(
>           evaluate([": foo dup ;", ": foo dup dup ;", "1 foo"]), [1, 1, 1]
        )

exercises/practice/forth/forth_test.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': foo dup ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
_ ForthTest.test_user_defined_words_can_use_different_words_with_the_same_name _

self = <forth_test.ForthTest testMethod=test_user_defined_words_can_use_different_words_with_the_same_name>

    def test_user_defined_words_can_use_different_words_with_the_same_name(self):
        self.assertEqual(
>           evaluate([": foo 5 ;", ": bar foo ;", ": foo 6 ;", "bar foo"]), [5, 6]
        )

exercises/practice/forth/forth_test.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': foo 5 ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
_________ ForthTest.test_user_defined_words_execute_in_the_right_order _________

self = <forth_test.ForthTest testMethod=test_user_defined_words_execute_in_the_right_order>

    def test_user_defined_words_execute_in_the_right_order(self):
>       self.assertEqual(evaluate([": countup 1 2 3 ;", "countup"]), [1, 2, 3])

exercises/practice/forth/forth_test.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
exercises/practice/forth/forth.py:77: in evaluate
    process_command(command)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

command = ': countup 1 2 3 ;'

    def process_command(command):
        tokens = command.upper().split()
        for token in tokens:
            if token.isdigit():  # Numbers get pushed onto the stack
                stack.append(int(token))
            elif token in definitions:  # Defined words are evaluated
                process_command(definitions[token])
            elif token == '+':
                require_stack_length(2)
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                require_stack_length(2)
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                require_stack_length(2)
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                require_stack_length(2)
                b, a = stack.pop(), stack.pop()
                if b == 0:
                    raise ZeroDivisionError("divide by zero")
                stack.append(a // b)
            elif token == 'DUP':
                require_stack_length(1)
                stack.append(stack[-1])
            elif token == 'DROP':
                require_stack_length(1)
                stack.pop()
            elif token == 'SWAP':
                require_stack_length(2)
                stack[-2], stack[-1] = stack[-1], stack[-2]
            elif token == 'OVER':
                require_stack_length(2)
                stack.append(stack[-2])
            elif token == ':':  # Start of word definition
                if not tokens:
                    raise ValueError("incomplete definition")
                name = tokens.pop(0)
                if not name.isalpha():
>                   raise ValueError("illegal operation")
E                   ValueError: illegal operation

exercises/practice/forth/forth.py:64: ValueError
=========================== short test summary info ============================
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_case_insensitivity_definitions_are_case_insensitive
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_case_insensitivity_user_defined_words_are_case_insensitive
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_parsing_and_numbers_pushes_negative_numbers_onto_the_stack
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_can_consist_of_built_in_words
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_can_define_word_that_uses_word_with_the_same_name
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_can_override_built_in_operators
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_can_override_built_in_words
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_can_override_other_user_defined_words
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_can_use_different_words_with_the_same_name
FAILED exercises/practice/forth/forth_test.py::ForthTest::test_user_defined_words_execute_in_the_right_order
======================== 10 failed, 38 passed in 0.17s =========================
